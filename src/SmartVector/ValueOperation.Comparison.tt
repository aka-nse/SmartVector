<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var types = new []{
    ("bool"   , false),
    ("byte"   , true ),
    ("ushort" , true ),
    ("uint"   , true ),
    ("ulong"  , true ),
    ("sbyte"  , true ),
    ("short"  , true ),
    ("int"    , true ),
    ("long"   , true ),
    ("float"  , false),
    ("double" , false),
    ("decimal", false),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
namespace SmartVector;

partial class ValueOperation
{
    /// <summary> Compares 2 values of <typeparamref name="T"/>. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Equals<T>(in T x, in T y)
    {
<# foreach(var (type, _) in types) { #>
        if(typeof(T) == typeof(<#=type#>))
        {
            var xx = Unsafe.As<T, <#=type#>>(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, <#=type#>>(ref Unsafe.AsRef(y));
            return xx == yy;
        }
<# } #>
        return Cache<T>.Instance.Equals(x, y);
    }


    /// <summary> Compares 2 values of <typeparamref name="T"/>. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Compare<T>(in T x, in T y)
    {
<# foreach(var (type, supported) in types) { #>
        if(typeof(T) == typeof(<#=type#>))
        {
<# if(supported) { #>
            var xx = Unsafe.As<T, <#=type#>>(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, <#=type#>>(ref Unsafe.AsRef(y));
            if(xx == yy)
                return 0;
            return xx > yy ? 1: -1;
<# } else { #>
            throw new NotSupportedException();
<# } #>
        }
<# } #>
        return Cache<T>.Instance.Compare(x, y);
    }
}
